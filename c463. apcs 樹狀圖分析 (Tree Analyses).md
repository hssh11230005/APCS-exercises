# c463. apcs 樹狀圖分析 (Tree Analyses)
## C++ 解法
### AC (0.1s, 3MB)
```C++
#include <bits/stdc++.h>
using namespace std;
#define N 100010

int main() {
    long long parent[N] = {0};  
    long long h[N] = {0};       
    long long deg[N];           
    queue<int> Q;
    int n, i, j, ch;
    cin >> n;

    for (i = 1; i <= n; i++) {
        cin >> deg[i];
        if (deg[i] == 0) Q.push(i);
        for (j = 0; j < deg[i]; j++) {
            cin >> ch;
            parent[ch] = i;
        }
    }

    int root = 0;
    long long total = 0; 
    while (!Q.empty()) {
        int v = Q.front();
        Q.pop();
        total += h[v]; 
        int p = parent[v];
        if (p == 0) {  
            root = v;
            break;
        }
        h[p] = max(h[p], h[v] + 1);
        if (--deg[p] == 0)  
            Q.push(p);
    }

    cout << root << endl;
    cout << total << endl;

    return 0;
}

```

## Python 解法
### AC (0.7s, 18.9MB)
```python
n = int(input())
parent = [-1]*n; deg = [0]*n; height = [0] * n
for i in range(n):
    a = [int(x)-1 for x in input().split()]
    deg[i] = len(a)-1
    for j in range(1, len(a)):
        parent[a[j]] = i
que = [x for x in range(n) if deg[x] == 0]
front = 0
root = parent.index(-1)
print(root+1)
while front < len(que):
    v = que[front]; front += 1; p = parent[v]
    if p < 0: break
    height[p] = max(height[p], height[v]+1); deg[p] -= 1
    if deg[p] == 0: que.append(p)

print(sum(height))
``` 